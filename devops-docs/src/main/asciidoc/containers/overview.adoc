:sectnums:
:sectanchors:

== Overview

Entando currently offers a variety of Docker images that can be used in different container environments, such as
'vanilla' Docker, Openshift or Kubernetes. These images were also developed with different use cases in mind, such as
the 'quick start' use case, CI/CD, production and demo use cases. Supporting so many different environments and use cases
inevitably comes with some level of complexity. In this chapter, we will gradually take you from the simpler use cases
to the more complex use cases, hopefully easing the learning curve required for using our Docker images.

== A word on Docker tooling.

While it is theoretically possible to manage this multitude of Entando Docker containers using the 'docker' command, we
strongly recommend using container management tools that allow you to manage multiple containers in concert.
Entando itself is typically deployed on Docker in sets of two to three images. As containerization gains
more traction in the industry, we expect more Entando Docker images to be added to these deployments. We therefor advise even
the die-hard 'docker' command line users to familiarize themselves with one a container management tool
that allows you to easily deploy, start and stop multiple containers collectively using a single command.

Entando supports Docker Compose and Openshift, both of which simplify the management of multiple Docker containers and setting
up connectivity amongst them. Since Entando Apps are still Java projects built with Maven, we have also added support
for the Maven Docker Plugin for multiple Entando Docker images to be built built and tested druing the development and
build processes. We have developed quick starts for all three these technologies to make it easier for new users to
get Entando up and running on Docker.

[[getting-started]]
== Geting Started

You can get started on Entando using either Docker Compose, the Maven Docker Plugin or Openshift. In order to choose the
option that fits your needs the best, consider the following:

* *Docker Compose:* For 'vanilla' Docker installations, the Docker Compose tool allows you to run
several of our images together by using one of the Docker Compose 'YAML' files that we offer. If you have some skill
in Docker, but you have limited interest or skills in development skills, this would be best way for you to get started.
You can deploy and run a selection of our pre-built, deployment-ready images as configured in our
https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack[Docker Compose 'YAML' files].
*  *Maven with Docker:* If you have some development skills, especially around the use of Maven, but
Docker is not necessarily (yet) your forte, this approach may be the best for you. We have a
https://github.com/entando/entando-archetypes/tree/EN-1885/web-app-bpm-docker/web-app-bpm-docker/src/main/resources/archetype-resources[Maven Archetype]
specifically developed to help you build your project image and run the resulting image in Docker.
* *Openshift:* If you have an Openshift environment at your disposal and you know how to deploy an
Openshift template, the Openshift approach would be best. Openshift doesn't require extensive
knowledge of either the Development world or the Ops world to get started, but it does reward your knowledge of either.
If DevOps is your thing, this approach is ideal for you, and you can choose from our selection of
https://github.com/entando/entando-ops/tree/credit-card-dispute/Openshift/templates[Openshift Templates] to suit your use case.


=== Docker Compose in a 'vanilla' Docker environment

.Prerequisites:
. You have installed Docker locally.
. You are either running a Linux distribution or MacOS. (Windows still to be tested)
. The https://docs.docker.com/compose/install/[docker-compose command line tool] has also been installed. Some Docker distributions may require you to install this separately.

.Steps:
. Download the Entando Full Stack docker-compose 'YAML' file from https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/docker-compose.yml[Github]
. Open a terminal window and change the present working directory to the directory that you have downloaded the yaml file to.
. It is highly recommended that you first pull the required images from Docker Hub running the command `docker-compose pull`
. Run the command `docker-compose up` to spin up the required Docker containers
. Open your browser and point it to http://localhost:5000. This will open the AppBuilder. Note that on Apple or Windows you won't be using localhost but rather the IP address of the Docker virtual machine.
. Use the credentials admin/adminadmin to log in. Consult our documentation for more details on how to build an Entando App from AppBuilder
. To open the resulting web app, point your browser to http://localhost:8080/entando. Note that on Apple or Windows you won't be using localhost but rather the IP address of the Docker virtual machine.

.Next steps

Now that you got started on Entando in your Docker platform, you have a couple of different options on how to proceed.
You can have a look at our <<demos-on-docker>> section to see some more demos that you can deploy to Docker. If you are
serious about getting your images deployed to production, we would recommend working through the <<openshift-quickstart>>
section, as Openshift is currently our recommended approach.

=== Maven and Docker

.Prerequisites:
. You have installed Docker locally.
. You have installed Java and Maven locally.
. You are either running a Linux distribution or MacOS. (Windows still to be tested)
. It is highly recommended that you have pulled the required images into your Docker environment
using the https://github.com/entando/entando-ops/blob/master/Docker/base-images/pull-quickstart-images.sh[pull-quickstart-images.sh script]

.Steps:
. Open a terminal to the directory you want to place your Maven project in.
. Run:

        mvn archetype:generate -DgroupId=org.entando -DartifactId=entando-docker && \
          -DarchetypeGroupId=org.entando.entando && \
          -DarchetypeArtifactId=entando-archetype-webapp-bpm-docker && \
          -DarchetypeVersion=5.0.2 && \
          -DinteractiveMode=false

. Change the present working directory to the folder of the newly generated project, `entando-docker`
. Run:

        mvn clean install -Pdocker docker:start -DskipAppBuilderImage=false

. Open your browser and point it to http://localhost:5000. This will open the AppBuilder
. Use the credentials admin/adminadmin to log in. Consult our documentation for more details on how to build an Entando App from AppBuilder
. To open the resulting web app, point your browser to http://localhost:8080/entando


.Next steps

Now that you got started on Entando using Maven and the Docker platform, you may want to
consider managing the database yourself, or how to use a different base image.
For guidance on how to do this, please consult our <<maven-and-docker>> section
on the use of Docker with our Maven archetypes. If you are serious about getting
your images deployed to production, we would recommend working through the <<openshift-quickstart>>
section, as Openshift is currently our recommended approach.


[[openshift-quickstart]]
===  Openshift Quick Start

.Prerequistes:
. You have access to a fully operational Openshift cluster (could also be a local Minishift installation).
. You have credentials to log into this environment.
. Your user has access to the project named 'openshift'
. It is highly recommended that you or your system admin has pulled all the required images into your Docker environment
using the https://github.com/entando/entando-ops/blob/master/Openshift/installers/pull-quickstart-images.sh[pull-quickstart-images.sh script]
. If you require RedHat Process Automation Manager, we recommend deploying the
https://access.redhat.com/documentation/en-us/red_hat_process_automation_manager/7.0/html-single/deploying_a_red_hat_process_automation_manager_7.0_authoring_environment_on_red_hat_openshift_container_platform/index[Authoring environment template]
 to Openshift and take down the connection details (baseUrl, username and password) of the KIE Server.

There are two different approaches you can follow to deploy Entando to your Openshift environment:

. Using the browser based console. This approach is ideal if you are new to Openshift, if you are not comfortable with the commandline terminal and
if you won't be expected to automate deployment and confguration any time soon.
. Using the `oc` command line interface. This approach is intended for the more low level technical audience, especially if you will be expected
to automate deployment and configuration.

.Steps using the browser based console:
. Log into the browser based console using your credentials.
. Navigate to the 'openshift' project
. Use the 'Add to project'->'Import YAML/JSON' menu item to import some files to your catalog. The easiest would be to open these files
in your browser and copy and paste their contents into the YAML/JSON text area.
.. the Entando EAP Quick Start image stream: https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/image-streams/entando-eap71-quickstart-openshift.json
.. the Entando AppBuilder image stream: https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/image-streams/appbuilder.json
.. the Entando EAO Quick Start template: https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/templates/entando-eap71-quickstart.yml
. Go back to the Openshift landing page by clicking the 'OPENSHIFT' text in the top left corner
. Click on the 'Create Project' button in the top right area and type in the name 'entando-sample' for your new project
. Click on the link that displays the newly created project's name
. Click on the 'Browse Catalog' button
. Scroll until you find the template 'Entando in EAP 7.1'. (Sometimes there is a delay before this item shows up. If you cannot find it, delete your project, go drink some coffee, and then recreate your project again.)
. Click on this template, and follow the wizard. When you are prompted for parameter values, type the following parameter values:
.. Find out from your admins what the default domain suffix is for your Openshift cluster, usually something like
   'YOUR.CLUSTER.IP.nip.io'. Decide what domain name you  want your Entando instance to run on by specifying the ENTANDO_RUNTIME_HOSTNAME_HTTP
   parameter, e.g. ENTANDO_RUNTIME_HOSTNAME_HTTP=entando.YOUR.CLUSTER.IP.nip.io
.. The ENTANDO_WEB_CONTEXT paramater should be set to "entando-sample" as this will be the context of the web app on the EAP server
.. *Custom http Route Hostname for the Entando runtime and legacy screens*: type 'entando.YOUR.CLUSTER.IP.nip.io'
.. If you have installed RedHat Process Automation Manager, you would require valid values for the following parameters:
... *KIE Server base url:*  the URL of the route that exposes the KIE Server
... *KIE Server Username:* The username that you configured for the KIE Server. This would be the value you provided for the 'KIE Server User' parameter
when installing  RedHat Process Automation Manager, or the value of the KIE_SERVER_USER environment variable on the KIE Server
deployment configuration in Openshift.
... *KIE Server Pasword:* The password that you configured for the KIE Server. This would be the value you provided for the 'KIE Server Password' parameter
when installing  RedHat Process Automation Manager, or the value of the KIE_SERVER_PWD environment variable on the KIE Server
deployment configuration in Openshift.
.. The default values would suffice for all the other parameters
. Navigate to the Builds->Builds menu item, confirm that a build has been triggered, and wait for this build to complete
. Once completed, navigate to Applications->Deployments and wait until you have two active deployments
. Once completed, navigate to Application->Routes and click on the URL for AppBuilder
. Log in using the credentials admin/adminadmin


.Steps using the `oc` command line interface:
. Log into your openshift cluster using `oc login -u USERNAME -p PASSWORD OPENSHIFT_CLUSTER_IP:8443` where
`OPENSHIFT_CLUSTER_IP` is the hostname or ip address of your Openshift cluster
. Set the current project to 'openshift': `oc project openshift`
. Install the following YAML and JSON files:
.. The Entando EAP image stream: `oc create -f https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/image-streams/entando-eap71-quickstart-openshift.json`
.. The Entando AppBuilder image stream: `oc create -f https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/image-streams/appbuilder.json`
.. The Quickstart template: `oc create -f https://raw.githubusercontent.com/entando/entando-ops/master/Openshift/templates/entando-eap71-quickstart.yml`
. Create an Openshift project for your Entando App: `oc new-project entando-sample`
. Deploy the template:
.. Determine what the default domain suffix is for your Openshift cluster, usually something like 'YOUR.CLUSTER.IP.nip.io'. Decide what domain name you
want your Entando instance to run on by specifying the ENTANDO_RUNTIME_HOSTNAME_HTTP parameter, e.g. ENTANDO_RUNTIME_HOSTNAME_HTTP=entando.YOUR.CLUSTER.IP.nip.io
.. The ENTANDO_WEB_CONTEXT paramater should be set to "entando-sample" as this will be the context of the web app on the EAP server
.. If you have installed RedHat Process Automation Manager, you would require valid values for the following parameters:
... KIE_SERVER_BASE_URL: the URL of the route that exposes the KIE Server
... KIE_SERVER_USERNAME: the username that you configured for the KIE Server. This would be the value you provided for the 'KIE Server User' parameter
when installling  RedHat Process Automation Manager, or the value of the KIE_SERVER_USER environment variable on the KIE Server
deployment configuration in Openshift.
... KIE_SERVER_PASSWORD: the password that you configured for the KIE Server. This would be the value you provided for the 'KIE Server Password' parameter
when installing  RedHat Process Automation Manager, or the value of the KIE_SERVER_PWD environment variable on the KIE Server
deployment configuration in Openshift.
.. Instantiating the template would then look something like this: `oc process openshift//entando-eap-quickstart -p ENTANDO_RUNTIME_HOSTNAME_HTTP=entando.YOUR.CLUSTER.IP.nip.io
-p ENTANDO_WEB_CONTEXT="entando-sample" -p KIE_SERVER_BASE_URL=kieserver.YOUR.CLUSTER.IP.nip.io -p KIE_SERVER_USERNAME=john_smith -p KIE_SERVER_PASSWORD=mypassword
|oc create -f -`
. Confirm that a build has been triggered by runnning: `oc get builds`. Wait for build to complete.
. Comfirm that two deployments have been triggered by running: `oc get dc`and then `oc get pods`. Wait until all pods are
in 'Running' status.
. Find the route that was generated for AppBuilder: `oc get routes` and navigate to its URL in your browser.
. Log in using the credentials admin/adminadmin

.Next steps

Now that you got started with Entando on Openshift, you may want to delve into the
process of managing the database yourself, or how to leverage Jenkins in Openshift
to setup your own pipeline, or how to promote your changes from one environment to the next.
For guidance on how to do this, please consult our <<entando-on-openshift>> section on
the use of our Openshift images and templates.

[[common-variables]]
== Common Variables on Docker
When running a Docker image, three different types of variables typically need to be provided by the user:

.. The environment variables required by the image
.. The ports on the host that will be used to exposed the container's ports on
.. The volumes on the host that will be used to map the container's hard drive volumes on

The Entando images consistently associate the same functionality with the same ports, volumes and environment variables.

=== Environment Variables for images hosting the Entando database
** **PORTDB_DATABASE** - the name of the Entando PORT database that is created and hosted in the image
** **PORTDB_USERNAME** - the username of the user that has read/write access to the Entando PORT database
** **PORTDB_PASSWORD** - the password of the above-mentioned username.
** **SERVDB_DATABASE** - the name of the Entando SERV database that is created and hosted in the image
** **SERVDB_USERNAME** - the username of the user that has read/write access to the Entando SERV database. For compatibility with mvn jetty:run, please keep this the same as PORTDB_USERNAME
** **SERVDB_PASSWORD** - the password of the above-mentioned username.  For compatibility with mvn jetty:run, please keep this the same as PORTDB_PASSWORD
** **ADMIN_USERNAME** - the username of a user that has admin rights on both databases. For compatibility with Postgresql, keep this value to 'postgres'
** **ADMIN_PASSWORD** - the password of the above-mentioned username.

=== Environment Variables for images hosting the Entando Engine
** **PORTDB_URL** - the full JDBC connection string used to connect to the Entando PORT database
** **PORTDB_JNDI** - the full JNDI name where the Entando PORT datasource will be made available to the Entando Engine JEE application
** **PORTDB_DRIVER** - the name of the driver for the Entando PORT database as configured in the JEE application server
** **PORTDB_USERNAME** - the username of the user that has read/write access to the Entando PORT database
** **PORTDB_PASSWORD** - the password of the above-mentioned username.
** **PORTDB_SERVICE_HOST** - the  name of the server that hosts the Entando PORT database.
** **PORTDB_SERVICE_PORT** - the port on the above-mentioned server that serves the Entando PORT database. Generally we keep to the default port for each RDBMS, e.g. for PostgreSQL it is 5432
** **SERVDB_URL** - the full JDBC connection string used to connect to the Entando SERV database
** **SERVDB_JNDI** - the full JNDI name where the Entando SERV datasource will be made available to the Entando Engine JEE application
** **SERVDB_DRIVER** - the name of the driver for the Entando SERV database as configured in the JEE application server
** **SERVDB_USERNAME** - the username of the user that has read/write access to the Entando SERV database
** **SERVDB_PASSWORD** - the password of the above-mentioned username.
** **SERVDB_SERVICE_HOST** - the  name of the server that hosts the Entando SERV database
** **SERVDB_SERVICE_PORT** - the port on the above-mentioned server that serves the Entando SERV database. Generally we keep to the default port for each RDBMS, e.g. for PostgreSQL it is 5432

=== Environment Variables for images hosting the AppBuilder (and other JavaScript apps)

** **DOMAIN** - the HTTP URL on which the associated Entando Engine instance will be served
** **CLIENT_SECRET** - the secret associated with the 'appbuilder' Oauth Client ID in the Entando OAuth infrastructure.

=== Common Ports

** **5000** - the port for the NodeJS HTTP Service on images that serve JavaScript applications
** **8080** - the port for the HTTP service hosted by JEE Servleit Containers on images that host Java services
** **8778** - the port for the JGroups service on JBoss/Wildfly on images that support JGroups
** **8443** - the port for  the HTTPS service hosted by JEE Servlet Containers that support HTTPS. (P.S. generally we prefer to configure HTTPS on a router such as the Openshift Router)

[[common-volumes]]
=== Common Volumes
** **/entando-data** - contains the data that will be used and/or generated by the Entando app running in the container. In order to keep things simple, we generally map the following Maven
filter properties to subdirectories inside this volume:

*** **profile.resources.path=/entando-data/resources** - this is where uploaded files are stored
*** **profile.resources.path.protected=/entando-data/protected** - this is where sensitive files are stored such as database backups
*** **profile.index.path=/entando-data/indexdir** - this is where Entando builds its indices
*** **Embedded Derby Databases: /entando-data/databases** this contains the embedded Derby database for optional use, which can be ignored if you are pointing to a different database.

[[demos-on-docker]]
== Demos on Docker

Entando offers a couple of demos, such as the Entando Full Stack demo we had a look at in the <<getting-started>> section. In this section we will delve a bit deeper into
these demos on Docker and the various options they offer you.

[[entando-ful-stack-demo]]
=== Default Entando Full Stack demo
This demo was briefly discussed in the <<getting-started>> section. The entando Full Stack demo deploys two images. Follow their links to read more about the image in question

** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/appbuilder[The Entando AppBuilder]
** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/entando[The Full Entando Engine API]

This demo exports the standard ports of 5000 and 8080 to the Docker host. On Linux this would be localhost, but on Windows and Apple it will be the IP address of the virtual machine
that hosts the Docker service.

The demo also allocates a local volume for the /entando-data volume. This volume contains the usual uploaded resources, protected and index files as described in the <<common-volumes>> section.
This particular configuration of the Entando Full Stack image comes with two pre-built embedded Derby databases that will be copied to the /entando-data/databases directory. Any changes
made to the underlying database will therefore be persisted in this volume and will thus survive container restarts, even when the container itself is removed.

To determine the location of the volume, first list the volumes using `docker volume ls` and then describe the
appropriate volume in more detail using `docker inspect entando-full-stack_entando-volume`. For Windows and Apple, keep in mind that those volumes are hosted inside the virtual machine
that hosts the Docker service. If you want to clear the volume, stop the Docker containers and run `docker volume rm entando-full-stack_entando-volume`. This will reset all data
stored in the volume.

=== Entando Full Stack on Postgresql

Wherease the default confguration of the Entando Full Stack image uses the two embeded Derby  databases, the configuration in
https://raw.githubusercontent.com/entando/entando-ops/credit-card-dispute/Docker/Production/entando-full-stack/docker-compose-postgresql.yml[docker-compose-postgresql.yml]
points Entando to an external database provided by our PostgreSQL. To run this demo, do the following:

.Steps:
. Download the Entando Full Stack docker-compose-postgresql.yml  file from https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/docker-compose-postgresql.yml[Github]
. Open a terminal window and change the present working directory to the directory that you have downloaded the yaml file to.
. It is highly recommended that you first pull the required images from Docker Hub running the command `docker-compose -f docker-compose-postgresql.yml pull`
. Run the command `docker-compose -f docker-compose-postgresql.yml up` to spin up the required Docker containers
. Open your browser and point it to http://localhost:5000. This will open the AppBuilder. Note that on Apple or Windows you won't be using localhost but rather the IP address of the Docker virtual machine.
. Use the credentials admin/adminadmin to log in. Consult our documentation for more details on how to build an Entando App from AppBuilder
. To open the resulting web app, point your browser to http://localhost:8080/entando. Note that on Apple or Windows you won't be using localhost but rather the IP address of the Docker virtual machine.
. To access the PostgreSQL databases, point your database client to jdbc:postgresql://localhost:5432 and connect using postgres/adminpwd. (On Apple or Windows use the IP address of the Docker virtual machine.)

The key difference between this demo and the <<entando-ful-stack-demo>> is that the database here is hosted in a different container. For this reason, this demo requires
two Docker volumes:

. entando-volume.
. entando-pg-volume.

The first volume contains the usual uploaded resources, protected and index files as described in the <<common-volumes>> section, but no database.
The second volume contains the PostgreSQL database. If you want to reset the database, please delete this volume and let the PostgreSQL image recreate the database.

For more information on the individual images that this demo is composed of, follow these links:

** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/appbuilder[The Entando AppBuilder Image]
** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/entando[The Full Entando Engine API Image]
** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/postgresql[The PostgreSQL Database Image]

=== FSI Credit Card Dispute Demo

The Entando team, Red Hat and our business partners have collaborated to bring you a demo that illustrates how Entando can be used as the user experience layer for your
Red Hat Process Automation Manager processes. The process in question allows customers to initiate a dispute case against a specific transaction. This demo provides
two Entando apps - a customer facing app and a back-office app. These apps connect to a shared KIE Server instance.

.Steps:
. Download the Entando FSI Credit Card Dispuate Demo docker-compose.yml  file from https://github.com/entando/entando-ops/blob/credit-card-dispute/Docker/demos/docker-compose.yml[Github]
. Open a terminal window and change the present working directory to the directory that you have downloaded the yaml file to.
. It is highly recommended that you first pull the required images from Docker Hub running the command `docker-compose pull`
. Run the command `docker-compose up` to spin up the required Docker containers
. Open your browser and point it to http://localhost:5001. This will open the AppBuilder for the customer facing app.
. Use the credentials aryaStark/adminadmin to log in. Consult our documentation for more details on how to build an Entando App from AppBuilder
. Point your browser to http://localhost:5002. This will open the AppBuilder for the back-office app.
. Use the credentials admin/adminadmin to log in. Consult our documentation for more details on how to build an Entando App from AppBuilder
. To open the customer facing web app, point your browser to http://localhost:8081/fsi-credit-card-dispute-customer. Use aryaStark/adminadmin to log in
. To open the back-office web app, point your browser to http://localhost:8082/fsi-credit-card-dispute-backoffice. Use admin/adminadmin to log in

Both images in this demo come with their own embedded Derby databases. These databases are stored in the following Docker volumes

. entando-customer-volume
. entando-admin-volume

For more information about the image this demo is composed of, follow these links:

** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/Production/entando-full-stack/appbuilder[The Entando AppBuilder Image]
** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/demos/fsi-cc-dispute-customer[The FSI Credit Card Dispute Customer Image]
** https://github.com/entando/entando-ops/tree/credit-card-dispute/Docker/demos/fsi-cc-dispute-admin[The FSI Credit Card Dispute Back Office Image]

This demo is configured by default to use Entando's public Red Hat PAM environment, where the necessary rules, processes and model objects have been pre-installed.


== Considerations for managing Entando's data



When designing a pipeline for an Entando App, the scope and granularity of the app plays a significant role in which pipeline approach to choose. By "scope", we need
to look specifically at the organisational scope of the app, that is who it is that needs to work on the app. If several people in your organisation work on an Entando
App, it is likely to be more coarse grained and your selected pipeline would look different compare to the pipeline of an Entando App that only has
one or two developers working on it. This section offers some guidelines to decide what the best pipeline approach would be for your specific use case

=== Coarse Grained Apps

A coarse grained Entando App typically involves a fairly complex site with a lot of content and a substantial database. In this case, you will find that
different authors with potentially different skillsets contribute to the site concurrently. It is also very likely that some of your authors may not have
strong development skills and would not be comfortable addressing conflicts at a source code level. For this reason, you are likely to rely more on
Entando's CMS functionality to ensure that concurrent work against the site produces the expected result with minimum conflicts.

If this describes your use case for Entando, you would need a shared environment that everyone can work on concurrently. As such, the database backing
this shared environment is an extremely important asset to your organisation, and you need to take care in how you propogate the state of this database
from one environment to the next. At this point in time, Entando doesn't have any specific features that could simplify this for you, and we suggest
using a third party database migration tool such as Liquibase. It is very important to ensure that the directory that you uploaded your content to
is promoted exactly the same time as the database, and the responsibility for this ultimately lies with your operations team.

In future releases of Entando we are hoping to provide some support for this use case.


=== Fine Grained Apps

A fine grained Entando App typically involves a smaller, self-container site. It would still involve some content and data, but not so much that you
need a fully fledged content management system to eliminate conflicts. If the authoers have more advanced development skills, they would be
able to sort out all potential conflicts using the source control management tool of their choice. In this case, the database remains small and simple
enough for you


[[maven-and-docker]]
= Maven and Docker

== mvn jetty:run

== Volumes
WIP. Talk about the two different volumes, what data resides there,

== Controlling the Database
WIP talk about PG image, selecting plugins, backups, restores, etc, how the copying works in new environments.
Connect to container. show mvn commands

== Using different base images
WIP talk about Wildfly, plans for Tomcat. show mvn commands

== Docker Host IP Complexities
WIP talk about how the Docker host is not always straight forward, and how Openshift has more to offer.

[[entando-on-openshift]]
= Entando on Openshift

== Fullstack template

== FSI Template

== Quickstart Template

== PostgreSQL template
WIP. Talk about selecting plugins, rebuild the database. Backup from tar files. Backup from sql files. Triggering builds
independently.


== Jenkins Pipelines


== Promoting to Production