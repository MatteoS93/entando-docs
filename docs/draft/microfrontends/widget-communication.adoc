= Tutorial: using custom event for widget communication
:toc:

Entando 6 widgets can communicate through https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent[Custom Events], an established web standard.

In this tutorial we're going to build two widgets: the first one will fire an event, the latter one will intercept it.

== Fire an event from a widget

link:create-react-microfrontend-widget.adoc[After creating a widget using our previous tutorial], rename `WidgetElement` to `PublisherWidgetElement` then edit it (and update the import in `index.js` accordingly).

We need to add some event firing logic

=== PublisherWidgetElement.js

[source,js]
----
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

const EVENTS = {
  greeting: 'greeting',
};

class PublisherWidgetElement extends HTMLElement {

  constructor() {
    super();
    this.onGreet = name => this.publishWidgetEvent(EVENTS.greeting, { name });
  }
  
  connectedCallback() {
    this.mountPoint = document.createElement('div');
    this.appendChild(this.mountPoint);
    this.render();
  }

  publishWidgetEvent(eventId, detail) {
    const widgetEvent = new CustomEvent(eventId, { detail });
    window.dispatchEvent(widgetEvent);
  }

  render() {
    ReactDOM.render(<App onGreet={this.onGreet} />, this.mountPoint);
  }
}

customElements.define('publisher-widget', PublisherWidgetElement);

export default PublisherWidgetElement;
----

[NOTE]
====
in the `CustomEvent` constructor, `detail` is the exact name to use in the event payload, as for the https://dom.spec.whatwg.org/#interface-customevent[specs].
====


=== App.js

[source,js]
----
import React from 'react';
import './App.css';

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { name: ''};
  }

  handleNameChange(value) {
    this.setState(prevState => ({
      ...prevState,
      name: value,
    }));
  }

  render() {
    const { name } = this.state;
    const { onGreet } = this.props;
    return (
      <div>
        <h1>Send a greeting</h1>
        <label htmlFor="name">Name</label>
        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />
        <button onClick={() => onGreet(name)}>Say hello!</button>
      </div>
    );
  }
}

export default App;
----

To quickly test the event publishing we can execute from the JS console this line of code
[source,js]
----
window.addEventListener('greeting', (evt) => console.log('Hello', evt.detail.name))
----

Then write something in the text field, click the "Say hello!" button and have a look ath the JS console: it will show the expected hello message.

== Consume an event in another widget

Now, let's create the subscriber widget. Generate and edit it using again the link:create-react-microfrontend-widget.adoc[basic microfrontend tutorial] and edit the following JS files:

=== SubscriberWidgetElement.js

(we're renaming `WidgetElement` to `SubscriberWidgetElement` and update the import in `index.js` accordingly)


[source,js]
----
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

const EVENTS = {
  greeting: 'greeting',
};

class SubscriberWidgetElement extends HTMLElement {

  constructor() {
    super();
    this.name = null;
    this.subscribeToWidgetEvent(EVENTS.greeting, (evt) => this.onGreeting(evt.detail.name));
  }
  
  connectedCallback() {
    this.mountPoint = document.createElement('div');
    this.appendChild(this.mountPoint);
    this.render();
  }

  subscribeToWidgetEvent(eventType, eventHandler) {
    window.addEventListener(eventType, eventHandler);
  }

  onGreeting(name) {
    this.name = name;
    this.render();
  }

  render() {
    ReactDOM.render(<App name={this.name} />, this.mountPoint);
  }
}

customElements.define('subscriber-widget', SubscriberWidgetElement);

export default SubscriberWidgetElement;
----


=== App.js

[source,js]
----
import React from 'react';
import './App.css';

function App({ name }) {
  return name ? (<h2>Just got a greeting from {name}</h2>) 
    : (<h2>Waiting for a greeting...</h2>);
}

export default App;
----

To quickly test the event publishing we can execute from the JS console these lines of code
[source,js]
----
const widgetEvent = new CustomEvent('greeting', {
  detail: {
    name: 'Pippo'
  },
});
window.dispatchEvent(widgetEvent);
----

And then the widget will update the text.

== Make both widgets work in Entando

To properly test widgets in an entando instance, follow those steps (you can use the link:create-react-microfrontend-widget.adoc[basic microfrontend tutorial] as reference)

* build both widgets
* copy widget files
* create widgets from App Builder
* create a page model from App Builder
* create a page and assign the just created page model
* configure the page dragging both widget

If you need a simple page model, you can use this one

*JSON Configuration*
[source,json]
----
{
  "frames": [
    {
      "pos": 0,
      "descr": "Sample Frame",
      "mainFrame": false,
      "defaultWidget": null,
      "sketch": null
    },
    {
      "pos": 1,
      "descr": "Sample Frame Two",
      "mainFrame": false,
      "defaultWidget": null,
      "sketch": null
    }
  ]
}
----


*Template*
[source,html]
----
<#assign wp=JspTaglibs["/aps-core"]>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title><@wp.currentPage param="title" /></title>
</head>
<body>
<h1><@wp.currentPage param="title" /></h1>
<div><@wp.show frame=0 /></div>
<div><@wp.show frame=1 /></div>
</body>
</html>
----

Now, go to the page you just created and you will find both widgets. Write something in the publisher widget input, press the button and the subscriber widget will update. Done!
