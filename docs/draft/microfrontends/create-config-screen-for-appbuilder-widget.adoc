= Tutorial: Add configuration screen for a App Builder widget
:toc:

Entando 6 widgets can be customized through a configuration screen so the citizen developers can avoid writing ad-hoc additional code.

In Entando 6, the leading microfrontend platform for Kubernetes, even the configuration screen is a microfrontend, more precisely a web component. That means you can develop and test it in isolation, without a running Entando instance.

Let's start with the boilerplate provided by https://create-react-app.dev/[Create React App], the most popular React app generator made by Facebook.

`npx create-react-app my-widget-config`

----
my-widget-config
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── serviceWorker.js
----

== Edit the root app component

Let's start with a dead simple form: only an input with a label. So, let's edit `App.js`

[source,js]
----
import React from 'react';

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = { name: ''};
  }

  handleNameChange(value) {
    this.setState(prevState => ({
      ...prevState,
      name: value,
    }));
  }

  render() {
    const { name } = this.state;
    return (
      <div>
        <h1>Sample Entando 6 Widget Configuration</h1>
        <label for="name">Name</label>
        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />
      </div>
    );
  }
}

export default App;
----

Of course you are free to use your favourite form handling library like Formik, redux-form (that requirese redux) or whatever. Up to you.

== Wrap the react app in a web component

Now, let's add the web component that will wrap the entire React app. Let's name it `WidgetElement`

[source,js]
----

import React from 'react';
import ReactDOM from 'react-dom';
import App from 'components/App';

class WidgetElement extends HTMLElement {
  constructor() {
    super();
    this.reactRootRef = React.createRef();
    this.mountPoint = null;
  }

  get config() {
    return this.reactRootRef.current ? this.reactRootRef.current.state : {};
  }

  set config(value) {
    return this.reactRootRef.current.setState(value);
  }

  connectedCallback() {
    this.mountPoint = document.createElement('div');
    this.appendChild(this.mountPoint);
    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);
  }
}

customElements.define('my-widget-config', WidgetElement);
----

Its responsability is rendering the react app and syncing the react app state in a `config` property, that _must_ be named that way. This is the secret sauce of widget <--> App builder communication that works in three steps:

* App Builder reads `config` property when the widget config screen is rendered
* `config` property is mutated when user configures the widget
* When the user manages to save the config, App Builder retrieves it (again, from the `config` property) and persists it through Entando APIs

That means the widget developer can focus on the configuration screens without having to call Entando APIs to read or write configuration.

Now, to ensure our web component is working we have to edit `public/index.html`

[source,html]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>React App</title>
  </head>
  <body>
    <my-widget-config>
  </body>
</html>
----

NOTE: the web component tag name (`my-widget-config`) _must_ match the one passed as parameter to `customElements.define` in `WidgetElement`.

Reload the page and...congrats! You're running an Entando 6 widget configuration screen.

== The react root component

Before integrating the widget config screen, we need some widget info. Open App Builder, go to UX Patterns -> Widgets and click on the installed widgtet we're creating the configuration screen for.

You'll a screen like that

(edit widget screenshot)

Take note of the `bundleId` value.

Now, time to build our widget before embedding it into the Entando 6 instance. From the react project root, type 

`npm run build`

and you will find three js files under `build/static/js` directory. Something like:

* `main.1fd3965a.chunk.js` (the actual app)
* `2.230b21ef.chunk.js` (the libraries the app uses)
* `runtime~main.c7dcdf0b.js` (the bootstrapping logic)

Now, edit again the widget and update the `configUI` field.

[source,json]
----
{
  "customElement": "my-widget-config",
  "resources": [
    "runtime~main.c7dcdf0b.js",
    "2.230b21ef.chunk.js",
    "main.1fd3965a.chunk.js",
  ]
}
----

NOTE: names in the `resources` array are a sample, you must match the ones generated by the `npm run build` script.

NOTE: `configUI` is a JSON object, so pay attention to save a well-formed one (the integrated JSON editor will help you).

NOTE: value for `customElement` must match the name of custom tag in `index.html` and the one passed as parameter to `customElements.define` in `WidgetElement`.

Now, copy the JS files under `<entando instance name>/target/<entando instance name>/<bundle id>`. The bundle id value is exactly the one you get from the widget edit screen we already mentioned.

Last step: configure a page, drag our widget into the page model slots and you'll see the configuration screen we just built.


**TODO**

* add screenshots
* improve formatting
* double check all is working following the tutorial
* should we write we're going to further automate things through generators and tools?
